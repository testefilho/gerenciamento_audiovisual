// Regras iniciais recomendadas para desenvolvimento.
// Ajuste conforme seu modelo de dados e requisitos de segurança antes de usar em produção.
// Regras fortalecidas com validação por campo e checagem de propriedade (ownerUid).
// Revise os limites/tamanhos conforme seus requisitos de produção.

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helpers
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(uid) {
      return uid == request.auth.uid;
    }

    // Validação de strings: obrigatório, tipo string, tamanho mínimo e máximo
    function validString(field, minLen, maxLen) {
      return field is string && field.size() >= minLen && field.size() <= maxLen;
    }

    // Campo string opcional (null/absent ou string com tamanho máximo)
    function validOptionalString(field, maxLen) {
      return (field == null) || (field is string && field.size() <= maxLen);
    }

    // Timestamp opcional (aceita null enquanto o serverTimestamp é aplicado)
    function validOptionalTimestamp(field) {
      return (field == null) || (field is timestamp);
    }

    // Validação do objeto infoGerais esperado no documento de evento
    function validInfoGerais(info) {
      return info is map
        && info.keys().hasAll(['evento-nome'])
        && validString(info['evento-nome'], 3, 100)
        && (info['evento-data'] == null || (info['evento-data'] is string && info['evento-data'].matches('^\\d{4}-\\d{2}-\\d{2}$')))
        && validOptionalString(info['local'], 200)
        && validOptionalString(info['descricao'], 1000);
    }

    function validEventoUpdate(resourceData, currentData) {
      // Não permitir mudança de ownerUid
      return (resourceData.ownerUid == currentData.ownerUid)
        && (resourceData.infoGerais == null || validInfoGerais(resourceData.infoGerais))
        && validOptionalTimestamp(resourceData.ultimaAtualizacao);
    }

    // Validação para itens do cronograma (tolerante a campos ausentes)
    function validCronograma(item) {
      // exigir ownerUid e acao
      return item.keys().hasAll(['ownerUid','acao'])
        && item.ownerUid is string
        && isOwner(item.ownerUid)
        && validString(item.acao, 1, 300)
        && (!item.keys().hasAny(['horario']) || validOptionalString(item.horario, 10)) // 'HH:MM' por exemplo
        && (!item.keys().hasAny(['tipo']) || validOptionalString(item.tipo, 30))
        && (!item.keys().hasAny(['observacoes']) || validOptionalString(item.observacoes, 1000))
        && (!item.keys().hasAny(['timestamp']) || validOptionalTimestamp(item.timestamp))
        ;
    }

    // Validação para vídeos
    function validVideo(item) {
      let allowedStatus = ['pendente','edicao','aprovacao','revisao','aprovado'];
      // exigir ownerUid e descricao
      return item.keys().hasAll(['ownerUid','descricao'])
        && item.ownerUid is string
        && isOwner(item.ownerUid)
        && validString(item.descricao, 5, 1000)
        && (!item.keys().hasAny(['categoria']) || validOptionalString(item.categoria, 50))
        && (!item.keys().hasAny(['tipo']) || validOptionalString(item.tipo, 50))
        && (!item.keys().hasAny(['horario']) || validOptionalString(item.horario, 20))
        && (!item.keys().hasAny(['duracao']) || validOptionalString(item.duracao, 20))
        && (!item.keys().hasAny(['formato']) || validOptionalString(item.formato, 50))
        && (!item.keys().hasAny(['status']) || (item.status is string && allowedStatus.hasAny([item.status])))
        && (!item.keys().hasAny(['timestamp']) || validOptionalTimestamp(item.timestamp))
        ;
    }

    // Validação para membros de equipe
    function validEquipe(item) {
      return item.keys().hasAll(['ownerUid','membro-nome'])
        && item.ownerUid is string
        && isOwner(item.ownerUid)
        && validString(item['membro-nome'], 1, 200)
        && (!item.keys().hasAny(['membro-funcao']) || validOptionalString(item['membro-funcao'], 100))
        && (!item.keys().hasAny(['timestamp']) || validOptionalTimestamp(item['timestamp']));
    }

    // Validação para entregas
    function validEntrega(item) {
      let allowedStatus = ['pendente','concluido'];
      return item.keys().hasAll(['ownerUid','entrega-titulo'])
        && item.ownerUid is string
        && isOwner(item.ownerUid)
        && validString(item['entrega-titulo'], 1, 300)
        && (!item.keys().hasAny(['entrega-prazo']) || (item['entrega-prazo'] is string && item['entrega-prazo'].matches('^\\d{4}-\\d{2}-\\d{2}$')))
        && (!item.keys().hasAny(['entrega-status']) || (item['entrega-status'] is string && allowedStatus.hasAny([item['entrega-status']])))
        && (!item.keys().hasAny(['timestamp']) || validOptionalTimestamp(item['timestamp']));
    }

    // Regra principal para coleção de eventos
    match /eventos/{eventoId} {
      // Leitura pública permitida (ajuste se necessário)
      allow read: if true;

  // Criação: somente usuário autenticado e ownerUid deve corresponder (validações adicionais podem bloquear chamadas REST indiretas)
  allow create: if isSignedIn()
          && request.resource.data.ownerUid == request.auth.uid;

      // Atualização e exclusão: apenas o owner registrado pode modificar e payload validado
      allow update: if resource.data.ownerUid == request.auth.uid
                      && validEventoUpdate(request.resource.data, resource.data);

      allow delete: if resource.data.ownerUid == request.auth.uid;

      // Subcoleções: cronograma e videos com validação por documento
    match /cronograma/{itemId} {
      allow read: if true;
      // For local E2E stability: allow create when the requester is signed in and the
      // request payload ownerUid matches the authenticated uid. This avoids race
      // conditions where get() may not be readable during security evaluations.
      allow create: if isSignedIn()
        && request.resource.data.ownerUid == request.auth.uid
        && validCronograma(request.resource.data);
      // For update/delete, require that the parent event exists and the owner matches.
      allow update: if exists(/databases/$(database)/documents/eventos/$(eventoId))
                && get(/databases/$(database)/documents/eventos/$(eventoId)).data.ownerUid == request.auth.uid
                && resource.data.ownerUid == request.auth.uid
                && validCronograma(request.resource.data);
      allow delete: if exists(/databases/$(database)/documents/eventos/$(eventoId))
                && get(/databases/$(database)/documents/eventos/$(eventoId)).data.ownerUid == request.auth.uid
                && resource.data.ownerUid == request.auth.uid;
    }

    match /videos/{videoId} {
      allow read: if true;
      // Relax create for E2E: rely on request.ownerUid matching the auth uid to allow
      // client-created docs without needing a parent get() during evaluation.
      allow create: if isSignedIn()
        && request.resource.data.ownerUid == request.auth.uid
        && validVideo(request.resource.data);
      allow update: if exists(/databases/$(database)/documents/eventos/$(eventoId))
                && get(/databases/$(database)/documents/eventos/$(eventoId)).data.ownerUid == request.auth.uid
                && resource.data.ownerUid == request.auth.uid
                && validVideo(request.resource.data);
      allow delete: if exists(/databases/$(database)/documents/eventos/$(eventoId))
                && get(/databases/$(database)/documents/eventos/$(eventoId)).data.ownerUid == request.auth.uid
                && resource.data.ownerUid == request.auth.uid;
    }
      
    match /equipe/{membroId} {
      allow read: if true;
      allow create: if isSignedIn()
        && request.resource.data.ownerUid == request.auth.uid
        && validEquipe(request.resource.data);
      allow update: if exists(/databases/$(database)/documents/eventos/$(eventoId))
                && get(/databases/$(database)/documents/eventos/$(eventoId)).data.ownerUid == request.auth.uid
                && resource.data.ownerUid == request.auth.uid
                && validEquipe(request.resource.data);
      allow delete: if exists(/databases/$(database)/documents/eventos/$(eventoId))
                && get(/databases/$(database)/documents/eventos/$(eventoId)).data.ownerUid == request.auth.uid
                && resource.data.ownerUid == request.auth.uid;
    }

    match /entregas/{entregaId} {
      allow read: if true;
      // Allow create when ownerUid in request matches authenticated user to avoid
      // race conditions in E2E. Keep stricter checks for updates/deletes.
      // Nota: para estabilidade E2E, checagem leve no create (ownerUid deve corresponder).
      // Validação completa é aplicada em update/delete para segurança em produção.
      allow create: if isSignedIn()
        && request.resource.data.ownerUid == request.auth.uid;
      allow update: if exists(/databases/$(database)/documents/eventos/$(eventoId))
                && get(/databases/$(database)/documents/eventos/$(eventoId)).data.ownerUid == request.auth.uid
                && resource.data.ownerUid == request.auth.uid
                && validEntrega(request.resource.data);
      allow delete: if exists(/databases/$(database)/documents/eventos/$(eventoId))
                && get(/databases/$(database)/documents/eventos/$(eventoId)).data.ownerUid == request.auth.uid
                && resource.data.ownerUid == request.auth.uid;
    }
    }

    // Padrão: negar tudo para outras coleções
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
